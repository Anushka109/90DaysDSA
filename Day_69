Water Jug problem using BFS

You are given an m liter jug and a n liter jug. Both the jugs are initially empty. The jugs donâ€™t have markings to allow measuring smaller quantities. You have to use the jugs to measure d liters of water where d is less than n. 

(X, Y) corresponds to a state where X refers to the amount of water in Jug1 and Y refers to the amount of water in Jug2 
Determine the path from the initial state (xi, yi) to the final state (xf, yf), where (xi, yi) is (0, 0) which indicates both Jugs are initially empty and (xf, yf) indicates a state which could be (0, d) or (d, 0).

The operations you can perform are: 

Empty a Jug, (X, Y)->(0, Y) Empty Jug 1
Fill a Jug, (0, 0)->(X, 0) Fill Jug 1
Pour water from one jug to the other until one of the jugs is either empty or full, (X, Y) -> (X-d, Y+d)
Examples: 

Input : 4 3 2
Output : {(0, 0), (0, 3), (3, 0), (3, 3), (4, 2), (0, 2)}

Here, we keep exploring all the different valid cases of the states of water in the jug simultaneously until and unless we reach the required target water.

As provided in the problem statement, at any given state we can do either of the following operations:

1. Fill a jug

2. Empty a jug

3. Transfer water from one jug to another until either of them gets completely filled or empty.

Running of the algorithm:

We start at an initial state in the queue where both the jugs are empty. We then continue to explore all the possible intermediate states derived from the current jug state using the operations provided. 

We also, maintain a visited matrix of states so that we avoid revisiting the same state of jugs again and again.

//Java program for water jug problem
//using BFS
import java.util.*;
 
class Pair{
    int j1, j2;
    List<Pair> path;
 
    Pair(int j1, int j2){
        this.j1 = j1;
        this.j2 = j2;
        path = new ArrayList<>();
    }
 
    Pair(int j1, int j2, List<Pair> _path){
        this.j1 = j1;
        this.j2 = j2;
 
        path = new ArrayList<>();
        path.addAll(_path);
        path.add(new Pair(this.j1,this.j2));
    }
}
 
public class GFG{
    public static void main(String[] args) throws java.lang.Exception{
        int jug1 = 4;
        int jug2 = 3;
        int target = 2;
 
        getPathIfPossible(jug1, jug2, target);
    }
   
     private static void getPathIfPossible(int jug1, int jug2, int target){
        boolean[][] visited = new boolean[jug1+1][jug2+1];
        Queue<Pair> queue = new LinkedList<>();
 
        //Initial State: Both Jugs are empty so,
        //initialise j1 j2 as 0 and put it in the path list
        Pair initialState = new Pair(0,0);
        initialState.path.add(new Pair(0,0));
        queue.offer(initialState);
 
        while(!queue.isEmpty()){
            Pair curr = queue.poll();
 
            //Skip already visited states and overflowing water states
            if(curr.j1 > jug1 || curr.j2 > jug2 || visited[curr.j1][curr.j2])
                continue;
            //mark current jugs state as visited
            visited[curr.j1][curr.j2] = true;
 
            //Check if current state has already reached
            //the target amount of water or not
            if(curr.j1 == target || curr.j2 == target){
                if(curr.j1 == target){
                    //If in our current state, jug1 holds the
                    //required amount of water, then we empty the jug2
                    //and push it into our path.
                    curr.path.add(new Pair(curr.j1,0));
                }
                else{
                    //else, If in our current state, jug2 holds the
                    //required amount of water, then we empty the jug1
                    //and push it into our path.
                    curr.path.add(new Pair(0,curr.j2));
                }
                int n = curr.path.size();
                System.out.println("Path of states of jugs followed is :");
                for(int i = 0; i < n; i++)
                    System.out.println(curr.path.get(i).j1+" , "+curr.path.get(i).j2);
                return;
            }
 
            //If we have not yet found the target, then we have three cases left
            //I. Fill the jug and Empty the other
            //II. Fill the jug and let the other remain untouched
              //III. Empty the jug and let the other remain untouched
            //IV. Transfer amounts from one jug to another
 
            //Please refer to the table attached above to understand
            //the cases that we are taking into consideration
 
            //Now,
            //I. Fill the jug and Empty the other
            queue.offer(new Pair(jug1, 0, curr.path));
            queue.offer(new Pair(0, jug2, curr.path));
 
            //II. Fill the jug and let the other remain untouched
            queue.offer(new Pair(jug1, curr.j2, curr.path));
            queue.offer(new Pair(curr.j1, jug2, curr.path));
             
              //III. Empty the jug and let the other remain untouched
              queue.offer(new Pair(0, curr.j2, curr.path));
            queue.offer(new Pair(curr.j1, 0, curr.path));
           
            //IV. Transfer water from one to another until one jug becomes empty
            //or until one jug becomes full in this process
           
              //Transferring water form jug1 to jug2
              int emptyJug = jug2-curr.j2;
            int amountTransferred = Math.min(curr.j1, emptyJug);
            int j2 = curr.j2+amountTransferred;
            int j1 = curr.j1-amountTransferred;
            queue.offer(new Pair(j1, j2,curr.path));
             
              //Tranferring water form jug2 to jug1
            emptyJug = jug1-curr.j1;
            amountTransferred = Math.min(curr.j2, emptyJug);
            j2 = curr.j2-amountTransferred;
            j1 = curr.j1+amountTransferred;
            queue.offer(new Pair(j1, j2,curr.path));
        }
 
        System.out.println("Not Possible to obtain target");
    }
}
Output
Path from initial state to solution state ::
0 0
5 0
0 5
5 5
3 7
3 0
Time Complexity: O(n*m).

Space Complexity: O(n*m).
